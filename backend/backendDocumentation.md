# Документация к бэкенд части музыкального сервиса

<details>
<summary><code>main.cpp</code></summary>

Файл main.cpp содержит точку входа в приложение и реализует WebSocket-сервер, который:

- Принимает входящие подключения.
- Обрабатывает текстовые сообщения в формате JSON.
- Делегирует логику команд классу ServerHandler.
- Отправляет клиенту JSON-ответ.

**Зависимости:**

- Boost.Beast / Boost.Asio — реализация WebSocket-сервера и сетевого ввода/вывода.
- nlohmann::json — парсинг и сериализация JSON.
- thread — необходим для некоторого пока что не реализованного функционала.

**int main(int argc, char* argv[])**

- Запускает WebSocket-сервер на 127.0.0.1:8080.
- Ожидает подключения клиентов.
- При подключении запускает сессию обработки сообщений в отдельном потоке.

**Возвращает:**

- 0 (EXIT_SUCCESS) при успешном завершении.
- 1 (EXIT_FAILURE) при критической ошибке запуска сервера.

</details>

<details>
<summary><code>ServerHandler.h</code></summary>

Этот файл реализует класс ServerHandler, который обрабатывает JSON-запросы от клиента для управления аудиоплеером.  
Основная задача — принимать команды (загрузка трека, воспроизведение, пауза, регулировка громкости, перемотка, аутентификация), выполнять их с помощью объекта AudioPlayer и возвращать клиенту JSON-ответ с результатом.

**Зависимости:**

- ServerHandler.h — заголовочный файл с объявлением класса ServerHandler.
- nlohmann/json.hpp — библиотека для работы с JSON в C++.
- <regex> — стандартная библиотека C++ для работы с регулярными выражениями.
- <string> — для работы со строками.
- <memory> — для управления умными указателями std::unique_ptr на AudioPlayer.
- AudioPlayer — класс, отвечающий за воспроизведение аудио.

**Функции:**

1. **ServerHandler::ServerHandler()**  
   - Инициализирует указатель player как nullptr.  
   - Устанавливает флаг running в true.

2. **nlohmann::json ServerHandler::handle_json(const nlohmann::json& request)**  
   Главный обработчик входящего JSON-запроса.  
   - Проверяет поле "command".  
   - В зависимости от команды вызывает соответствующий обработчик:  
     "load", "resume", "pause", "quit", "seeking", "volume", "auth".  
   - Если команда неизвестна — возвращает ошибку.  
   - Любые исключения ловит и возвращает как ошибку.

3. **bool ServerHandler::is_running() const**  
   - Проверка, активен ли обработчик.  
   - Используется для выхода по команде "quit".

4. **nlohmann::json ServerHandler::handle_load(const nlohmann::json& j)**  
   - Загружает аудиофайл по пути, запускает воспроизведение.  
   - Проверяет корректность поля "path".  
   - Если плеер существует — останавливает и сбрасывает.  
   - Создаёт новый AudioPlayer.  
   - Инициализирует плеер, если ошибка — возвращает ошибку.  
   - Запускает воспроизведение.

5. **nlohmann::json ServerHandler::handle_resume()**  
   - Возобновляет воспроизведение.  
   - Проверяет, есть ли плеер, вызывает playAudio().

6. **nlohmann::json ServerHandler::handle_pause()**  
   - Ставит воспроизведение на паузу.  
   - Проверяет наличие плеера, вызывает pauseAudio().

7. **nlohmann::json ServerHandler::handle_quit()**  
   - Останавливает плеер, сбрасывает указатель, устанавливает running в false.

8. **nlohmann::json ServerHandler::handle_seek(const nlohmann::json& j)**  
   - Перематывает трек к позиции (число от 0.0 до 1.0).  
   - Проверяет player, поле "position" и корректность значения.  
   - Вызывает seekTo(position).

9. **nlohmann::json ServerHandler::handle_volume(const nlohmann::json& j)**  
   - Устанавливает уровень громкости (число от 0.0 до 1.0).  
   - Записывает level, вызывает setVolume(level) если трек загружен.

10. **bool is_valid_email_or_login(const std::string& input)**  
    - Проверяет корректность email или логина с помощью regex.

11. **bool is_valid_password(const std::string& password)**  
    - Проверяет пароль по правилам: длина 8–20, латинские буквы, цифры, символы ._-, содержит хотя бы один буквенно-цифровой символ.

12. **nlohmann::json ServerHandler::handle_auth(const nlohmann::json& request)**  
    - Проверяет логин и пароль.  
    - Возвращает "ACCEPTED" или "REJECTED" с сообщением.

</details>

# AudioPlayer

Класс `AudioPlayer` реализует аудиоплеер на базе FFmpeg и SDL2.  
Он позволяет загружать аудиофайл, инициализировать декодер, управлять воспроизведением (play, pause, stop), перематывать аудио по позиции и регулировать громкость.

---

## Зависимости

- **FFmpeg:**

  - `libavformat` — для открытия и чтения медиафайлов.
  - `libavcodec` — для декодирования аудиопотоков.
  - `libswresample` — для ресемплинга аудио в нужный формат.

- **SDL2** — для вывода аудио на звуковое устройство.

- Стандартные библиотеки C++ (`<cstdint>`) — для типов данных.

---

## Поля

| Поле                         | Описание                                                                                          |
|------------------------------|---------------------------------------------------------------------------------------------------|
| `const char* filename`        | Путь к аудиофайлу, который воспроизводится.                                                     |
| `AVFormatContext* formatCtx`  | Контекст формата файла, отвечает за открытие и чтение аудиофайла FFmpeg.                         |
| `AVCodecContext* codecCtx`    | Контекст кодека для декодирования аудио потока.                                                 |
| `int streamIndex`             | Индекс аудио потока внутри файла.                                                               |
| `SwrContext* swrCtx`          | Контекст ресемплинга для конвертации аудио в формат, совместимый с SDL.                          |
| `AVPacket* packet`            | Пакет данных аудиопотока (сжатые данные).                                                       |
| `AVFrame* frame`              | Раскодированный аудиофрейм (сырые аудиоданные).                                                 |
| `uint8_t* audioBuffer`        | Буфер для хранения декодированных аудиоданных, которые SDL воспроизводит.                        |
| `int bufferSize`              | Размер аудиобуфера.                                                                              |
| `int bufferIndex`             | Текущая позиция чтения внутри аудиобуфера.                                                     |
| `SDL_AudioSpec spec`          | Параметры аудиоустройства SDL (частота, формат, каналы и callback).                             |
| `bool isPlaying`              | Статус воспроизведения: играет ли аудио в данный момент.                                        |
| `float volume`                | Уровень громкости (от 0.0 до 1.0), применяемый к аудиоданным.                                  |
| `AudioData* audioData`        | Структура с аудиоданными и состоянием для callback-функции SDL.                                |

---

## Функции

### 1) `AudioPlayer::AudioPlayer(const char* filename)`

Конструктор класса `AudioPlayer`, предназначенный для создания объекта аудиоплеера с указанием пути к аудиофайлу, который впоследствии будет открыт и воспроизведён.

---

### 2) `bool AudioPlayer::init()`

**Назначение:**  
Метод инициализирует аудиоплеер, открывая аудиофайл, настраивая декодер и аудиосистему для последующего воспроизведения.  
Возвращает `true`, если инициализация прошла успешно, и `false` — в случае ошибок.

**Основные шаги:**

- **Инициализация сетевой подсистемы FFmpeg:**  
  Вызов `avformat_network_init()` для поддержки работы с сетевыми потоками.

- **Открытие аудиофайла:**  
  Использование `avformat_open_input()`. При ошибках возвращается `false`.

- **Получение информации о потоках:**  
  Вызов `avformat_find_stream_info()`. Неудача прерывает инициализацию.

- **Поиск аудиопотока:**  
  Перебор потоков для поиска с типом `AVMEDIA_TYPE_AUDIO`. Если не найден, ошибка.

- **Настройка кодека:**  
  Получение параметров, поиск декодера, выделение контекста, копирование параметров и открытие кодека.

- **Настройка ресемплера:**  
  Создание `SwrContext` для конвертации аудио в формат, совместимый с SDL (обычно 16-bit PCM, 44100 Гц, 2 канала).

- **Инициализация SDL для аудио:**  
  Вызов `SDL_Init(SDL_INIT_AUDIO)`. Настройка `SDL_AudioSpec` с частотой 44100 Гц, форматом `AUDIO_S16SYS`, 2 каналами, размером буфера 1024 сэмплов и callback-функцией `audioCallback`.

- **Выделение буфера аудиоданных:**  
  Выделение буфера размером 192000 байт.

- **Создание структуры AudioData:**  
  Сбор всех параметров и указателей для callback SDL.

- **Открытие аудиоустройства SDL:**  
  Вызов `SDL_OpenAudio()`. При ошибках возвращается `false`.

- **Успешное завершение:**  
  Возвращается `true` при успешной инициализации.

---

### `void AudioPlayer::audioCallback(void* userdata, Uint8* stream, int len)`

**Назначение:**  
Заполняет аудиобуфер SDL звуковыми данными для воспроизведения — декодирует аудиопоток, ресемплирует, применяет громкость и копирует звук в выходной буфер.

**Основные шаги:**  
- Проверка наличия данных в буфере.  
- При необходимости — чтение и декодирование следующего аудиофрейма.  
- Ресемплирование аудио под формат SDL.  
- Применение громкости.  
- Копирование звуковых данных в `stream`.  
- При достижении конца файла — заполнение буфера тишиной.

---

### `void AudioPlayer::cleanup()`

Закрывает аудио, освобождает пакеты, кадры, контексты кодека и формата, ресемплер, и завершает SDL.

---

### `void AudioPlayer::playAudio()`

Если аудио не играет, снимает паузу с SDL аудио.

---

### `void AudioPlayer::pauseAudio()`

Если аудио играет, ставит SDL аудио на паузу.

---

### `void AudioPlayer::stopAudio()`

Если аудио играет, ставит SDL аудио на паузу и сбрасывает состояние плеера.

---

### `bool AudioPlayer::seekTo(double position)`

Перематывает аудио на позицию в пределах от 0.0 до 1.0 (доля от длительности).  
Вычисляет целевое время, вызывает `av_seek_frame`, очищает декодер и сбрасывает буферы.  

- **Вход:** позиция — число с плавающей точкой.  
- **Выход:** `true`, если перемотка успешна, иначе `false`.

---

### `void AudioPlayer::setVolume(float vol)`

**Назначение:**  
Устанавливает уровень громкости в диапазоне 0.01–1.0.

**Вход:** уровень громкости (float).  
**Выход:** нет.

**Логика:**  
Клипирует значение по границам, обновляет внутреннее поле и структуру для callback-а.
