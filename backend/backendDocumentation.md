# Документация к бэкенд части музыкального сервиса

<details>
<summary><b>main.cpp</b></summary>

Файл main.cpp содержит точку входа в приложение и реализует WebSocket-сервер, который:

- Принимает входящие подключения.
- Обрабатывает текстовые сообщения в формате JSON.
- Делегирует логику команд классу ServerHandler.
- Отправляет клиенту JSON-ответ.

Зависимости:

- Boost.Beast / Boost.Asio — реализация WebSocket-сервера и сетевого ввода/вывода.
- nlohmann::json — парсинг и сериализация JSON.
- thread — необходим для некоторого, пока что не реализованного функционала.

`int main(int argc, char* argv[])`

- Запускает WebSocket-сервер на localhost для соединение с графическим интерфейсом.
- Ожидает подключения клиентов.
- При подключении запускает сессию обработки сообщений в отдельном потоке.

Возвращает:

- 0 (EXIT_SUCCESS) при успешном завершении.
- 1 (EXIT_FAILURE) при критической ошибке запуска сервера.

</details>

<details>
<summary><b>ServerHandler.h</b></summary>

Этот файл реализует класс ServerHandler, который обрабатывает JSON-запросы от клиента для управления аудиоплеером.  
Основная задача — принимать команды (загрузка трека, воспроизведение, пауза, регулировка громкости, перемотка, аутентификация), выполнять их с помощью объекта AudioPlayer и возвращать клиенту JSON-ответ с результатом.

Зависимости:

- ServerHandler.h — заголовочный файл с объявлением класса ServerHandler.
- nlohmann/json.hpp — библиотека для работы с JSON в C++.
- `<regex>` — для работы с регулярными выражениями (валидация логина, email и пароля).
- `<string>` — для работы со строками.
- `<memory>` — для управления умными указателями std::unique_ptr на AudioPlayer.
- AudioPlayer — собственный класс для воспроизведения аудио.

---

### Функции

1. **ServerHandler::ServerHandler()**

- Конструктор класса.
- Инициализирует указатель player как nullptr.
- Устанавливает флаг running в true, означая что обработчик активен.

2. **nlohmann::json ServerHandler::handle_json(const nlohmann::json& request)**

- Главный обработчик входящего JSON-запроса.
- Вход: JSON с обязательным полем "command".
- Выход: JSON-ответ с результатом или ошибкой.

Логика:

- Проверяет наличие и корректность поля "command".
- В зависимости от команды вызывает соответствующий обработчик:
  - `"load"` → `handle_load()`
  - `"resume"` → `handle_resume()`
  - `"pause"` → `handle_pause()`
  - `"quit"` → `handle_quit()`
  - `"seeking"` → `handle_seek()`
  - `"volume"` → `handle_volume()`
  - `"auth"` → `handle_auth()`
- Если команда неизвестна — возвращает ошибку.
- Любые исключения ловит и возвращает как ошибку.

3. **bool ServerHandler::is_running() const**

- Проверка, активен ли обработчик.
- Выход: true — если обработчик работает; false — если нужно завершить сессию.
- Используется в основном цикле сервера для выхода по команде `"quit"`.

4. **nlohmann::json ServerHandler::handle_load(const nlohmann::json& j)**

- Загрузка аудиофайла по пути, запуск воспроизведения.
- Вход: JSON с обязательным полем `"path"` — путь к аудиофайлу.
- Выход: JSON с `"status": "Playing"` или ошибкой.

Логика:

- Проверяет корректность поля `"path"`.
- Если плеер уже существует — останавливает его и сбрасывает.
- Создаёт новый объект AudioPlayer с переданным файлом.
- Инициализирует плеер, если не удалось — возвращает ошибку.
- Запускает воспроизведение.


4.1 **nlohmann::json ServerHandler::handle_load_only(const nlohmann::json& j)**
  -Тоже самое что и предыдущая, но без проигрывания.

5. **nlohmann::json ServerHandler::handle_resume()**

- Возобновляет воспроизведение.
- Выход: JSON с `"status": "Resumed"` или ошибкой, если трек не загружен.
- Проверяет, есть ли плеер, вызывает `playAudio()`.

6. **nlohmann::json ServerHandler::handle_pause()**

- Ставит воспроизведение на паузу.
- Выход: JSON с `"status": "Paused"` или ошибкой.
- Логика: Проверяет наличие плеера, вызывает `pauseAudio()`.

7. **nlohmann::json ServerHandler::handle_quit()**

- Останавливает плеер, сбрасывает указатель, устанавливает флаг running в false.
- Выход: JSON с `"status": "Stopped"`.

8. **nlohmann::json ServerHandler::handle_seek(const nlohmann::json& j)**

- Перематывает трек к указанной позиции.
- Вход: JSON с полем `"position"` — число от 0.0 до 1.0.
- Выход: JSON с `"status": "Seeked"` или ошибкой.

Логика:

- Проверяет существует ли player.
- Проверяет наличие и корректность поля `"position"`.
- Вызывает `seekTo(position)`.

9. **nlohmann::json ServerHandler::handle_volume(const nlohmann::json& j)**

- Устанавливает уровень громкости.
- Вход: JSON с полем `"level"` — число от 0.0 до 1.0.
- Выход: JSON с `"status": "Volume set to X"` или ошибкой.

Логика:

- Записывает уровень в `volume_level`.
- Вызывает `setVolume(level)`, если трек загружен.

10. **bool is_valid_email_or_login(const std::string& input)**

- Проверяет, является ли строка корректным email или логином.
- Если есть символ '@', применяет regex для email.
- Иначе — проверяет regex логина (буквы, цифры, `_`, `.`, `-`).

11. **bool is_valid_password(const std::string& password)**

- Проверяет пароль на корректность.
- Правила:
  - Длина от 8 до 20 символов.
  - Только латинские буквы, цифры и символы `._-`.
  - Должен содержать хотя бы один буквенно-цифровой символ.

12. **nlohmann::json ServerHandler::handle_auth(const nlohmann::json& request)**

- Проверяет логин и пароль на соответствие правилам.
- Вход: JSON с `"login"` и `"password"`.
- Выход: JSON с результатом:
  - `"status": "ACCEPTED"` и сообщение о корректности, или
  - `"status": "REJECTED"` с указанием на ошибки.

Логика:

- Проверяет наличие и тип полей.
- Использует вспомогательные функции проверки.
- Формирует ответ.

</details>

<details>
<summary><b>AudioPlayer</b></summary>

Класс AudioPlayer реализует аудиоплеер на базе FFmpeg и SDL2.  
Он позволяет загружать аудиофайл, инициализировать декодер, управлять воспроизведением (play, pause, stop), перематывать аудио по позиции и регулировать громкость.

---

Зависимости:

- FFmpeg:
  - libavformat — для открытия и чтения медиафайлов.
  - libavcodec — для декодирования аудиопотоков.
  - libswresample — для ресемплинга аудио в нужный формат.
- SDL2 — для вывода аудио на звуковое устройство.
- Стандартные библиотеки C++ (`<cstdint>`) — для типов данных.

---

### Поля

- `const char* filename` — Путь к аудиофайлу.
- `AVFormatContext* formatCtx` — Контекст формата файла.
- `AVCodecContext* codecCtx` — Контекст кодека для декодирования аудио.
- `int streamIndex` — Индекс аудио потока.
- `SwrContext* swrCtx` — Контекст ресемплинга аудио.
- `AVPacket* packet` — Пакет данных аудиопотока.
- `AVFrame* frame` — Раскодированный аудиофрейм.
- `uint8_t* audioBuffer` — Буфер для декодированных аудиоданных.
- `int bufferSize` — Размер аудиобуфера.
- `int bufferIndex` — Текущая позиция чтения в буфере.
- `SDL_AudioSpec spec` — Параметры аудиоустройства SDL.
- `bool isPlaying` — Статус воспроизведения.
- `float volume` — Уровень громкости (0.0 — 1.0).
- `AudioData* audioData` — Структура с аудиоданными и состоянием для callback SDL.

---

### Функции

1. **AudioPlayer::AudioPlayer(const char* filename)**

- Конструктор с указанием пути к аудиофайлу.

2. **bool AudioPlayer::init()**

- Инициализирует плеер: открывает файл, настраивает декодер и аудиосистему.
- Возвращает `true`, если успешно, иначе `false`.

Основные шаги:

- Инициализация сетевой подсистемы FFmpeg (`avformat_network_init()`).
- Открытие аудиофайла (`avformat_open_input()`).
- Получение информации о потоках (`avformat_find_stream_info()`).
- Поиск аудиопотока.
- Инициализация декодера аудио.
- Настройка ресемплинга аудио в формат, совместимый с SDL2.
- Инициализация SDL аудио.

3. **void AudioPlayer::playAudio()**

- Запускает аудиовоспроизведение.
- Включает SDL аудиоустройство.

4. **void AudioPlayer::pauseAudio()**

- Ставит воспроизведение на паузу.

5. **void AudioPlayer::stopAudio()**

- Останавливает воспроизведение.
- Очищает ресурсы.

6. **void AudioPlayer::seekTo(float position)**

- Перематывает аудиофайл на позицию в интервале [0.0, 1.0].
- Использует `av_seek_frame` с учётом времени.

7. **void AudioPlayer::setVolume(float vol)**

- Устанавливает уровень громкости от 0.0 до 1.0.

8. **int AudioPlayer::audioCallback(void* userdata, uint8_t* stream, int len)**

- Функция обратного вызова SDL, вызываемая при необходимости подгрузить аудио данные в буфер воспроизведения.
- Копирует декодированные аудиоданные из внутреннего буфера в поток SDL, применяя уровень громкости.

---

### Описание работы

- При инициализации происходит загрузка файла и настройка декодера.
- После вызова playAudio SDL начинает запрашивать аудиоданные через callback.
- Callback декодирует аудиофреймы, конвертирует их в формат SDL и передаёт на вывод.
- pauseAudio и stopAudio управляют состоянием вывода.
- seekTo позволяет перемотать трек.
- setVolume регулирует громкость.

---

При необходимости могу расписать детали по отдельным функциям или показать исходный код.

</details>
